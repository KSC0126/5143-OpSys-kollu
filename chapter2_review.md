# Chapter 2 Review Questions
Name: Showrya chakra kollu
Course: 5143 Operating Systems
Date: 16 FEB 2016

## 1. What are three objectives of an OS design?
Answer: convenience, efficiency, ability to evolve 
Convenience: An operating system provides convenience to the user for using computer.
Efficiency: Operating system helps to use computer in efficient manner
Ability: Operating system should permit effective, development, texting, and introduction to new system function without interfering with service 
 
## 2. What is the kernel of an OS?
Answer:  The kernel is a computer program that manages input/output requests from software and translates them into data processing instructions for the central processing unit and other electronic components of a computer. 


## 3. What is multiprogramming?
Answer: Multiprogramming also known as multitasking, memory is expanded to hold more than two programs or many and switch among all of them

## 4. What is a process?
Answer: A process is an instance of a computer program that is being executed. It contains the program code and its current activity. Depending on the operating system, a process may be made up of multiple threads of execution that execute instructions concurrently.

## 5. How is the execution context of a process used by the OS?
Answer: Execution context of a process is known as process state. It is an internal data that controls and supervises a process of the operating system. The initial execution of a process starts when the process starts the operating system taking the required data to the main memory. It contains current instruction of an application next executing instruction and allocated resource information.

## 6. List and briefly explain five storage management responsibilities of a typical OS?
Answer: Operating systems have five principal storage management responsibilities.
i) Process isolation: Independent processes should not interfere with each other's memory, both data and instructions. Operating system will prevent this from happening 
ii) Automatic allocation and management: Dynamically allocation should be done when programs are allocated across the memory hierarchy as required. Transparency should be maintained during the allocation process. Thus, the operating system can achieve efficiency by assigning memory to jobs only as needed
iii) Support of modular programming: Programmers should be able to define program modules, and to create, destroy, and alter the size of modules dynamically.
iv) Protection and access control: Sharing of memory, at any level of the memory hierarchy, creates the potential for one program to address the memory space of another. This is desirable when sharing is needed by particular applications. At other times, it threatens the integrity of programs and even of the operating system itself. The operating system must allow portions of memory to be accessible in various ways by various users
v) Long-term storage: It is a process where memory is stored for a long period of time even when the computer is switch off. It is stored in RAM.



##7. Explain the distinction between a real address and a virtual address?
Answer:
Real Address: An address seen by memory unit that is, the one loaded into the memory address register of the memory is referred to as Real address. A real address is a binary number in the form of logical high and low states on an address bus that corresponds to a particular cell of primary storage also known as main memory. Real addressing means that your program actually knows the real layout of RAM. Real address and logical addresses are same when using compile time and load time address binding but they differ when using execution time address binding. Real address ranges from where R is the base value.
Virtual Address: An address generated by CPU is referred to as Virtual address. The set of all logical address generated by a program is a logical address space. The user program deals with logical address or these are generated by user. Virtual addressing has many benefits. It protects programs from crashing each other through poor pointer manipulation, etc. Because each program has its own distinct virtual memory set, no program can read another's data - this is both a safety and a security plus. The translation from virtual to Real addresses is performed by the Memory Management Unit, which is a hardware device. The user program deals with virtual address it never sees the real address. Virtual address ranges from 0 to max.

##8. Describe the round-robin scheduling technique?
Round-robin (RR) is one of the algorithms employed by process and network schedulers in computing. As the term is generally used, time slices are assigned to each process in equal portions and in circular order, handling all processes without priority (also known as cyclic executive). Round-robin scheduling is simple, easy to implement, and starvation-free. Round-robin scheduling can also be applied to other scheduling problems, such as data packet scheduling in computer networks.

## 9. Explain the difference between a monolithic kernel and a microkernel? 
Answer:
Monolithic kernel: A monolithic kernel is an operating system architecture where the entire operating system is working in kernel space and is alone in supervisor mode. The monolithic model differs from other operating system architectures such the microkernel architecture in that it alone defines a high-level virtual interface over computer hardware. A set of primitives or system calls implement all operating system services such as process management, concurrency, and memory management. Device drivers can be added to the kernel as modules.
Micro kernel: A microkernel architecture assigns only a few essential functions to the kernel, including address spaces, inter process communication (IPC), and basic scheduling. Other OS services are provided by processes, sometimes called servers, that run in user mode and are treated like any other application by the microkernel. This approach decouples kernel and server development. Servers may be customized to specific application or environment requirements. The microkernel approach simplifies implementation, provides flexibility, and is well suited to a distributed environment. In essence, a microkernel interacts with local and remote server processes in the same way, facilitating construction of distributed systems.

## 10. What is multithreading?
Answer: Multithreading is a technique in which a process, executing an application, is divided into threads that can run concurrently. Thread is a dispatch able unit of work. It includes a processor context and its own data area for a stack. A thread executes sequentially and is interruptible so that the processor can turn to another thread.

## 11. List the key design issues for an SMP operating system?
Answer: 
• Simultaneous concurrent processes or threads: Kernel routines need to be reentrant to allow several processors to execute the same kernel code simultaneously. With multiple processors executing the same or different parts of the kernel, kernel tables and management structures must be managed properly to avoid data corruption or invalid operations.
• Scheduling: Any processor may perform scheduling, which complicates the task of enforcing a scheduling policy and assuring that corruption of the scheduler data structures is avoided. If kernel-level multithreading is used, then the opportunity exists to schedule multiple threads from the same process simultaneously on multiple processors.
• Synchronization: With multiple active processes having potential access to shared address spaces or shared I/O resources, care must be taken to provide effective synchronization. Synchronization is a facility that enforces mutual exclusion and event ordering.
• Memory management: Memory management on a multiprocessor must deal with all of the issues found on uniprocessor computers. In addition, the OS needs to exploit the available hardware parallelism to achieve the best performance. The paging mechanisms on different processors must be coordinated to enforce consistency when several processors share a page or segment and to decide on page replacement. The reuse of physical pages is the biggest problem of concern; that is, it must be guaranteed that a physical page can no longer be accessed with its old contents before the page is put to a new use.
Reliability and fault tolerance: The OS should provide graceful degradation in the face of processor failure. The scheduler and other portions of the OS must recognize the loss of a processor and restructure management tables accordingly.





















